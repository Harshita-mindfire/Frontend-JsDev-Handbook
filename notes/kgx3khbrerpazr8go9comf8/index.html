<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="icon" href="/Frontend-JsDev-Handbook/favicon.ico"/><title>Rendering</title><meta name="robots" content="index,follow"/><meta name="googlebot" content="index,follow"/><meta name="description" content="Personal Knowledge Space"/><meta property="og:title" content="Rendering"/><meta property="og:description" content="Personal Knowledge Space"/><meta property="og:url" content="https://Harshita-mindfire.github.io/Frontend-JsDev-Handbook/notes/kgx3khbrerpazr8go9comf8/"/><meta property="og:type" content="article"/><meta property="article:published_time" content="7/29/2025"/><meta property="article:modified_time" content="7/29/2025"/><link rel="canonical" href="https://Harshita-mindfire.github.io/Frontend-JsDev-Handbook/notes/kgx3khbrerpazr8go9comf8/"/><meta name="next-head-count" content="14"/><link rel="preload" href="/Frontend-JsDev-Handbook/_next/static/css/d70c9756212654c3.css" as="style"/><link rel="stylesheet" href="/Frontend-JsDev-Handbook/_next/static/css/d70c9756212654c3.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/Frontend-JsDev-Handbook/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/Frontend-JsDev-Handbook/_next/static/chunks/webpack-7ae598a7290a332d.js" defer=""></script><script src="/Frontend-JsDev-Handbook/_next/static/chunks/framework-28c999baf2863c3d.js" defer=""></script><script src="/Frontend-JsDev-Handbook/_next/static/chunks/main-99db8cbbcbcf3a6e.js" defer=""></script><script src="/Frontend-JsDev-Handbook/_next/static/chunks/pages/_app-c8281554a3681fc9.js" defer=""></script><script src="/Frontend-JsDev-Handbook/_next/static/chunks/935-4dee79e80b8641c6.js" defer=""></script><script src="/Frontend-JsDev-Handbook/_next/static/chunks/6-50972def09142ee2.js" defer=""></script><script src="/Frontend-JsDev-Handbook/_next/static/chunks/pages/notes/%5Bid%5D-78d472fa3b924116.js" defer=""></script><script src="/Frontend-JsDev-Handbook/_next/static/xOzf4DPnOhx7yXDruly4o/_buildManifest.js" defer=""></script><script src="/Frontend-JsDev-Handbook/_next/static/xOzf4DPnOhx7yXDruly4o/_ssgManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><section class="ant-layout" style="width:100%;min-height:100%"><header class="ant-layout-header" style="position:fixed;isolation:isolate;z-index:1;width:100%;border-bottom:1px solid #d4dadf;height:64px;padding:0 24px 0 2px"><div class="ant-row ant-row-center" style="max-width:992px;justify-content:space-between;margin:0 auto"><div style="display:flex" class="ant-col ant-col-xs-20 ant-col-sm-4"></div><div class="ant-col gutter-row ant-col-xs-0 ant-col-sm-20 ant-col-md-20 ant-col-lg-19"><div class="ant-select ant-select-lg ant-select-auto-complete ant-select-single ant-select-allow-clear ant-select-show-search" style="width:100%"><div class="ant-select-selector"><span class="ant-select-selection-search"><input type="search" autoComplete="off" class="ant-select-selection-search-input" role="combobox" aria-haspopup="listbox" aria-owns="undefined_list" aria-autocomplete="list" aria-controls="undefined_list" aria-activedescendant="undefined_list_0" value=""/></span><span class="ant-select-selection-placeholder">For full text search please use the &#x27;?&#x27; prefix. e.g. ? Onboarding</span></div></div></div><div style="display:none;align-items:center;justify-content:center" class="ant-col ant-col-xs-4 ant-col-sm-4 ant-col-md-0 ant-col-lg-0"><span role="img" aria-label="menu" style="font-size:24px" tabindex="-1" class="anticon anticon-menu"><svg viewBox="64 64 896 896" focusable="false" data-icon="menu" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M904 160H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8zm0 624H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8zm0-312H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8z"></path></svg></span></div></div></header><section class="ant-layout" style="margin-top:64px;display:flex;flex-direction:row"><div class="site-layout-sidebar" style="flex:0 0 auto;width:calc(max((100% - 992px) / 2, 0px) + 200px);min-width:200px;padding-left:calc((100% - 992px) / 2)"><aside class="ant-layout-sider ant-layout-sider-dark" style="position:fixed;overflow:auto;height:calc(100vh - 64px);background-color:transparent;flex:0 0 200px;max-width:200px;min-width:200px;width:200px"><div class="ant-layout-sider-children"></div></aside></div><main class="ant-layout-content side-layout-main" style="max-width:1200px;min-width:0;display:block"><div style="padding:0 24px"><div class="main-content" role="main"><div class="ant-row"><div class="ant-col ant-col-24"><div class="ant-row" style="margin-left:-10px;margin-right:-10px"><div style="padding-left:10px;padding-right:10px" class="ant-col ant-col-xs-24 ant-col-md-18"><div><h1 id="rendering">Rendering<a aria-hidden="true" class="anchor-heading icon-link" href="#rendering"></a></h1>
<ul>
<li>CSR</li>
<li>SSR</li>
<li>SSG</li>
<li>suspense SSR</li>
<li>React server components</li>
</ul>
<h2 id="client-side-rendering">Client side rendering<a aria-hidden="true" class="anchor-heading icon-link" href="#client-side-rendering"></a></h2>
<ul>
<li>The approach where browser(client) transforms react components into what you see on screen.</li>
</ul>
<p><img src="/Frontend-JsDev-Handbook/assets/images/CSR.png" alt="alt text"></p>
<h3 id="drawbacks-of-csr">Drawbacks of CSR<a aria-hidden="true" class="anchor-heading icon-link" href="#drawbacks-of-csr"></a></h3>
<ul>
<li>
<p><strong>SEO</strong>: When SEs crawl your site, they are looking for HTMl content to understand what the page is about. But with CSR, the page source is basically an empty div. Since content relies on JS to render on Client site, SE struggles to index it properly.</p>
</li>
<li>
<p><strong>Performance and UX</strong>: users can suffer from slow load times, as their browser download, parse and execute JS before seeing any meaningful content.</p>
</li>
</ul>
<h2 id="server-side-solutions">Server side solutions<a aria-hidden="true" class="anchor-heading icon-link" href="#server-side-solutions"></a></h2>
<p><img src="/Frontend-JsDev-Handbook/assets/images/SSR.png" alt="alt text"></p>
<ol>
<li>Static Site Generation (SSG)</li>
<li>Server-Side Rendering (SSR)</li>
</ol>
<p>SSG happens during build time when you deploy your application to the server. This results in pages that are already rendered and ready to serve. It's perfect for content that stays relatively stable, like blog posts</p>
<p>SSR, on the other hand, renders pages on-demand when users request them. It's ideal for personalized content like social media feeds where the HTML changes based on who's logged in.</p>
<h3 id="hydration">Hydration<a aria-hidden="true" class="anchor-heading icon-link" href="#hydration"></a></h3>
<p>(react adding interactivity to the server rendered HTML)</p>
<p>During hydration, React takes control in the browser and reconstructs the component tree in memory, using the server-rendered HTML as a blueprint</p>
<p>It carefully maps out where all the interactive elements should go, then hooks up the JavaScript logic</p>
<p>This involves initializing application state, adding click and mouseover handlers, and setting up all the dynamic features needed for a full interactive user experience.</p>
<h3 id="drawbacks-of-ssr">Drawbacks of SSR<a aria-hidden="true" class="anchor-heading icon-link" href="#drawbacks-of-ssr"></a></h3>
<ul>
<li><strong>You have to fetch everything before you can show anything</strong></li>
</ul>
<p>Components cannot start rendering and then pause or "wait" while data is still being loaded</p>
<p>If a component needs to fetch data from a database or another source (like an API), this fetching must be completed before the server can begin rendering the page</p>
<p>This can delay the server's response time to the browser, as the server must finish collecting all necessary data before any part of the page can be sent to the client</p>
<ul>
<li><strong>You have to load everything before you can hydrate anything</strong></li>
</ul>
<p>For successful hydration, where React adds interactivity to the server-rendered HTML, the component tree in the browser must exactly match the server-generated component tree</p>
<p>This means that all the JavaScript for the components must be loaded on the client before you can start hydrating any of them.</p>
<ul>
<li><strong>You have to hydrate everything before you can interact with anything</strong></li>
</ul>
<p>React hydrates the component tree in a single pass, meaning once it starts hydrating, it won't stop until it's finished with the entire tree</p>
<p>As a consequence, all components must be hydrated before you can interact with any of them.</p>
<h3 id="suspense-ssr">Suspense SSR<a aria-hidden="true" class="anchor-heading icon-link" href="#suspense-ssr"></a></h3>
<p>Use the <code>&#x3C;Suspense></code> componenet to unlock 2 major SSR features:</p>
<ul>
<li>HTML streaming on server</li>
<li>Selective hydration on the client.</li>
</ul>
<p>This solves the 3 all or nothing concerns of SSR: </p>
<ol>
<li>having to load the data for the entire page. 
<blockquote>
<p>React 18+ can fix this via <code>&#x3C;Suspense></code></p>
</blockquote>
</li>
<li>loading the JavaScript for the entire page
<blockquote>
<p>can be fixed with code splitting.</p>
</blockquote>
</li>
<li>hydrating the entire page.
<blockquote>
<p>Suspense also allows React to let hydrate other parts of the page before the section wrapped within it is ready. This is what we call: <strong>selective hydration</strong>. In scenarios where multiple components are awaiting hydration, React prioritizes hydration based on user interactions</p>
</blockquote>
</li>
</ol>
<p>at once, create an "all or nothing" waterfall problem that spans from the server to the client, where each issue must be resolved before moving to the next one</p>
<h3 id="drawbacks-of-suspense-ssr">Drawbacks of suspense ssr<a aria-hidden="true" class="anchor-heading icon-link" href="#drawbacks-of-suspense-ssr"></a></h3>
<p>raises 3 question:</p>
<ol>
<li>do user still need to download so much data(loading entire webpage bit by bit)</li>
<li>should all components be hydrated, even those that don't need interactivity(static content components)</li>
<li>Shouldn't we be leverging our servers more(user's device do bulk of the JS work which can slow things down)</li>
</ol>
<h3 id="react-server-components">React Server components<a aria-hidden="true" class="anchor-heading icon-link" href="#react-server-components"></a></h3>
<p></p><p></p><div class="portal-container">
<div class="portal-head">
<div class="portal-backlink">
<div class="portal-title">From <span class="portal-text-title">React Server Components</span></div>
<a href="/Frontend-JsDev-Handbook/notes/ubgj4b3onoq9pj080dri1nj" class="portal-arrow">Go to text <span class="right-arrow">→</span></a>
</div>
</div>
<div id="portal-parent-anchor" class="portal-parent" markdown="1">
<div class="portal-parent-fader-top"></div>
<div class="portal-parent-fader-bottom"></div><p><strong>The app router in Nextjs is built entirely on RSC architecture. All these features are built into the latest version of Nextjs</strong></p>
<h2 id="takeaways">Takeaways<a aria-hidden="true" class="anchor-heading icon-link" href="#takeaways"></a></h2>
<ul>
<li>React Server Components offer a new approach to building React apps by separating components into two: Server Components and Client Components</li>
<li>Server Components run exclusively on the server - they fetch data and prepare content without sending code to the browser</li>
<li>This makes your app faster because users download less code</li>
</ul>
<p>However, they can't handle any interactions</p>
<ul>
<li>Client Components, on the other hand, run in the browser and manage all the interactive parts like clicks and typing</li>
<li>They can also get an initial server render for faster page loads</li>
</ul>
<h2 id="react-server-components-1">React Server components<a aria-hidden="true" class="anchor-heading icon-link" href="#react-server-components-1"></a></h2>
<p>evolution of react CSR--> SSR ---> Suspense SSR---> RSC</p>
<ul>
<li>
<p>represents a new architechture, which leverages the strengths of both server and client environments to optimize efficiency, load times and interactivity..</p>
</li>
<li>
<p>Introduces dual models:</p>
<ul>
<li>client components</li>
<li>server components</li>
</ul>
</li>
</ul>
<p>This distiction is based on the environment they would execute and the specific systems they are designed to interact with, for eg: browser apis, hooks, goes in client components.</p>
<h3 id="client-components">Client components<a aria-hidden="true" class="anchor-heading icon-link" href="#client-components"></a></h3>
<ul>
<li>first rendered on the server then on the client.</li>
<li>in nextjs, use "use client" to differentiate the components as a CC.</li>
</ul>
<h3 id="server-components">Server components<a aria-hidden="true" class="anchor-heading icon-link" href="#server-components"></a></h3>
<ul>
<li>Server Components represent a new type of React component specifically designed to operate exclusively on the server</li>
<li>And unlike client components, their code stays on the server and is never downloaded to the client </li>
<li>This design choice offers multiple benefits to React applications</li>
</ul>
<p><strong>Benefits</strong></p>
<ul>
<li><strong>Smaller bundle sizes</strong>: Since Server Components stay on the server, all their dependencies stay there too. This is fantastic for users with slower connections or less powerful devices since they don't need to download, parse, and execute that JavaScript.
Plus, there's no hydration step, making your app load and become interactive faster</li>
<li><strong>Direct access to server-side resources</strong>: Server Components <strong>can talk directly to databases and file systems</strong>, making data fetching super efficient without any client-side processing.
They use the server's power and proximity to data sources to manage compute-intensive rendering tasks.</li>
<li><strong>Enhanced security</strong>: Since SC only run on server, sensitive data like API keys never leave the server.</li>
<li><strong>Improved data fetching</strong>: since SC are closer to data source, this can improve performance by reducing time it takes to fetch data needed for rendering.</li>
<li><strong>Caching</strong>: can cache the results and reuse them for different users and requests</li>
<li><strong>Faster initial load &#x26; FCP</strong>: By generating HTML on the server, users see your content immediately- no waiting for JS to download and execute.</li>
<li><strong>Improved SEO</strong></li>
<li><strong>Efficient Streaming</strong>: SC can split the rendering process into chunks that stream to client as they're ready. This means users start seeing content faster instead of waiting for entire page to render on the server.</li>
</ul>
<p>Server components handle data fetching and static rendering, client components take care of rendering the interactive elements.</p>
<h3 id="rsc-payload">rsc payload<a aria-hidden="true" class="anchor-heading icon-link" href="#rsc-payload"></a></h3>
<ul>
<li>these files have a special JSOn format are generated by react for each route and represent your virtual DOM in a super compavct way using abbreviations and internal references.</li>
<li>fr server components it also includes the actual rendered result.</li>
<li>CC rsc payload is a bit different,it has placeholders showing where the CC should go + refernces to their JS files</li>
</ul>
</div></div><p></p><p></p>
<hr>
<strong>Children</strong>
<ol>
<li><a href="/Frontend-JsDev-Handbook/notes/ubgj4b3onoq9pj080dri1nj">React Server Components</a></li>
</ol></div></div><div style="padding-left:10px;padding-right:10px" class="ant-col ant-col-xs-0 ant-col-md-6"><div><div class=""><div class="ant-anchor-wrapper dendron-toc" style="max-height:calc(100vh - 64px);z-index:1"><div class="ant-anchor"><div class="ant-anchor-ink"><span class="ant-anchor-ink-ball"></span></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#client-side-rendering" title="Client side rendering">Client side rendering</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#drawbacks-of-csr" title="Drawbacks of CSR">Drawbacks of CSR</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#server-side-solutions" title="Server side solutions">Server side solutions</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#hydration" title="Hydration">Hydration</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#drawbacks-of-ssr" title="Drawbacks of SSR">Drawbacks of SSR</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#suspense-ssr" title="Suspense SSR">Suspense SSR</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#drawbacks-of-suspense-ssr" title="Drawbacks of suspense ssr">Drawbacks of suspense ssr</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#react-server-components" title="React Server components">React Server components</a></div></div></div></div></div></div></div></div></div></div></div><div class="ant-divider ant-divider-horizontal" role="separator"></div><footer class="ant-layout-footer" style="padding:0 24px 24px"></footer></main></section></section></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"note":{"id":"kgx3khbrerpazr8go9comf8","title":"Rendering","desc":"","updated":1753789040778,"created":1753789040778,"custom":{},"fname":"learning.nextjs.rendering","type":"note","vault":{"fsPath":".","selfContained":true,"name":"Harshita-notes","sync":"sync"},"contentHash":"101d9f16b2af2016cbe0d64934454f3d","links":[{"type":"ref","from":{"fname":"learning.nextjs.rendering","id":"kgx3khbrerpazr8go9comf8","vaultName":"Harshita-notes"},"value":"learning.nextjs.rendering.react-server-components","position":{"start":{"line":94,"column":1,"offset":4125},"end":{"line":94,"column":55,"offset":4179},"indent":[]},"xvault":false,"to":{"fname":"learning.nextjs.rendering.react-server-components"}}],"anchors":{"client-side-rendering":{"type":"header","text":"Client side rendering","value":"client-side-rendering","line":14,"column":0,"depth":2},"drawbacks-of-csr":{"type":"header","text":"Drawbacks of CSR","value":"drawbacks-of-csr","line":19,"column":0,"depth":3},"server-side-solutions":{"type":"header","text":"Server side solutions","value":"server-side-solutions","line":28,"column":0,"depth":2},"hydration":{"type":"header","text":"Hydration","value":"hydration","line":40,"column":0,"depth":3},"drawbacks-of-ssr":{"type":"header","text":"Drawbacks of SSR","value":"drawbacks-of-ssr","line":49,"column":0,"depth":3},"suspense-ssr":{"type":"header","text":"Suspense SSR","value":"suspense-ssr","line":72,"column":0,"depth":3},"drawbacks-of-suspense-ssr":{"type":"header","text":"Drawbacks of suspense ssr","value":"drawbacks-of-suspense-ssr","line":92,"column":0,"depth":3},"react-server-components":{"type":"header","text":"React Server components","value":"react-server-components","line":99,"column":0,"depth":3}},"children":["ubgj4b3onoq9pj080dri1nj"],"parent":"w1drku1nbeoq0yf2h0ii7lx","data":{}},"body":"\u003ch1 id=\"rendering\"\u003eRendering\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#rendering\"\u003e\u003c/a\u003e\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003eCSR\u003c/li\u003e\n\u003cli\u003eSSR\u003c/li\u003e\n\u003cli\u003eSSG\u003c/li\u003e\n\u003cli\u003esuspense SSR\u003c/li\u003e\n\u003cli\u003eReact server components\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"client-side-rendering\"\u003eClient side rendering\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#client-side-rendering\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eThe approach where browser(client) transforms react components into what you see on screen.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg src=\"/Frontend-JsDev-Handbook/assets/images/CSR.png\" alt=\"alt text\"\u003e\u003c/p\u003e\n\u003ch3 id=\"drawbacks-of-csr\"\u003eDrawbacks of CSR\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#drawbacks-of-csr\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eSEO\u003c/strong\u003e: When SEs crawl your site, they are looking for HTMl content to understand what the page is about. But with CSR, the page source is basically an empty div. Since content relies on JS to render on Client site, SE struggles to index it properly.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003ePerformance and UX\u003c/strong\u003e: users can suffer from slow load times, as their browser download, parse and execute JS before seeing any meaningful content.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"server-side-solutions\"\u003eServer side solutions\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#server-side-solutions\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003e\u003cimg src=\"/Frontend-JsDev-Handbook/assets/images/SSR.png\" alt=\"alt text\"\u003e\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eStatic Site Generation (SSG)\u003c/li\u003e\n\u003cli\u003eServer-Side Rendering (SSR)\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eSSG happens during build time when you deploy your application to the server. This results in pages that are already rendered and ready to serve. It's perfect for content that stays relatively stable, like blog posts\u003c/p\u003e\n\u003cp\u003eSSR, on the other hand, renders pages on-demand when users request them. It's ideal for personalized content like social media feeds where the HTML changes based on who's logged in.\u003c/p\u003e\n\u003ch3 id=\"hydration\"\u003eHydration\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#hydration\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e(react adding interactivity to the server rendered HTML)\u003c/p\u003e\n\u003cp\u003eDuring hydration, React takes control in the browser and reconstructs the component tree in memory, using the server-rendered HTML as a blueprint\u003c/p\u003e\n\u003cp\u003eIt carefully maps out where all the interactive elements should go, then hooks up the JavaScript logic\u003c/p\u003e\n\u003cp\u003eThis involves initializing application state, adding click and mouseover handlers, and setting up all the dynamic features needed for a full interactive user experience.\u003c/p\u003e\n\u003ch3 id=\"drawbacks-of-ssr\"\u003eDrawbacks of SSR\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#drawbacks-of-ssr\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eYou have to fetch everything before you can show anything\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eComponents cannot start rendering and then pause or \"wait\" while data is still being loaded\u003c/p\u003e\n\u003cp\u003eIf a component needs to fetch data from a database or another source (like an API), this fetching must be completed before the server can begin rendering the page\u003c/p\u003e\n\u003cp\u003eThis can delay the server's response time to the browser, as the server must finish collecting all necessary data before any part of the page can be sent to the client\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eYou have to load everything before you can hydrate anything\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eFor successful hydration, where React adds interactivity to the server-rendered HTML, the component tree in the browser must exactly match the server-generated component tree\u003c/p\u003e\n\u003cp\u003eThis means that all the JavaScript for the components must be loaded on the client before you can start hydrating any of them.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eYou have to hydrate everything before you can interact with anything\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eReact hydrates the component tree in a single pass, meaning once it starts hydrating, it won't stop until it's finished with the entire tree\u003c/p\u003e\n\u003cp\u003eAs a consequence, all components must be hydrated before you can interact with any of them.\u003c/p\u003e\n\u003ch3 id=\"suspense-ssr\"\u003eSuspense SSR\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#suspense-ssr\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eUse the \u003ccode\u003e\u0026#x3C;Suspense\u003e\u003c/code\u003e componenet to unlock 2 major SSR features:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eHTML streaming on server\u003c/li\u003e\n\u003cli\u003eSelective hydration on the client.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThis solves the 3 all or nothing concerns of SSR: \u003c/p\u003e\n\u003col\u003e\n\u003cli\u003ehaving to load the data for the entire page. \n\u003cblockquote\u003e\n\u003cp\u003eReact 18+ can fix this via \u003ccode\u003e\u0026#x3C;Suspense\u003e\u003c/code\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003c/li\u003e\n\u003cli\u003eloading the JavaScript for the entire page\n\u003cblockquote\u003e\n\u003cp\u003ecan be fixed with code splitting.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003c/li\u003e\n\u003cli\u003ehydrating the entire page.\n\u003cblockquote\u003e\n\u003cp\u003eSuspense also allows React to let hydrate other parts of the page before the section wrapped within it is ready. This is what we call: \u003cstrong\u003eselective hydration\u003c/strong\u003e. In scenarios where multiple components are awaiting hydration, React prioritizes hydration based on user interactions\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eat once, create an \"all or nothing\" waterfall problem that spans from the server to the client, where each issue must be resolved before moving to the next one\u003c/p\u003e\n\u003ch3 id=\"drawbacks-of-suspense-ssr\"\u003eDrawbacks of suspense ssr\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#drawbacks-of-suspense-ssr\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eraises 3 question:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003edo user still need to download so much data(loading entire webpage bit by bit)\u003c/li\u003e\n\u003cli\u003eshould all components be hydrated, even those that don't need interactivity(static content components)\u003c/li\u003e\n\u003cli\u003eShouldn't we be leverging our servers more(user's device do bulk of the JS work which can slow things down)\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"react-server-components\"\u003eReact Server components\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#react-server-components\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e\u003c/p\u003e\u003cp\u003e\u003c/p\u003e\u003cdiv class=\"portal-container\"\u003e\n\u003cdiv class=\"portal-head\"\u003e\n\u003cdiv class=\"portal-backlink\"\u003e\n\u003cdiv class=\"portal-title\"\u003eFrom \u003cspan class=\"portal-text-title\"\u003eReact Server Components\u003c/span\u003e\u003c/div\u003e\n\u003ca href=\"/Frontend-JsDev-Handbook/notes/ubgj4b3onoq9pj080dri1nj\" class=\"portal-arrow\"\u003eGo to text \u003cspan class=\"right-arrow\"\u003e→\u003c/span\u003e\u003c/a\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv id=\"portal-parent-anchor\" class=\"portal-parent\" markdown=\"1\"\u003e\n\u003cdiv class=\"portal-parent-fader-top\"\u003e\u003c/div\u003e\n\u003cdiv class=\"portal-parent-fader-bottom\"\u003e\u003c/div\u003e\u003cp\u003e\u003cstrong\u003eThe app router in Nextjs is built entirely on RSC architecture. All these features are built into the latest version of Nextjs\u003c/strong\u003e\u003c/p\u003e\n\u003ch2 id=\"takeaways\"\u003eTakeaways\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#takeaways\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eReact Server Components offer a new approach to building React apps by separating components into two: Server Components and Client Components\u003c/li\u003e\n\u003cli\u003eServer Components run exclusively on the server - they fetch data and prepare content without sending code to the browser\u003c/li\u003e\n\u003cli\u003eThis makes your app faster because users download less code\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eHowever, they can't handle any interactions\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eClient Components, on the other hand, run in the browser and manage all the interactive parts like clicks and typing\u003c/li\u003e\n\u003cli\u003eThey can also get an initial server render for faster page loads\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"react-server-components-1\"\u003eReact Server components\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#react-server-components-1\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eevolution of react CSR--\u003e SSR ---\u003e Suspense SSR---\u003e RSC\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003erepresents a new architechture, which leverages the strengths of both server and client environments to optimize efficiency, load times and interactivity..\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eIntroduces dual models:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eclient components\u003c/li\u003e\n\u003cli\u003eserver components\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThis distiction is based on the environment they would execute and the specific systems they are designed to interact with, for eg: browser apis, hooks, goes in client components.\u003c/p\u003e\n\u003ch3 id=\"client-components\"\u003eClient components\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#client-components\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003efirst rendered on the server then on the client.\u003c/li\u003e\n\u003cli\u003ein nextjs, use \"use client\" to differentiate the components as a CC.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"server-components\"\u003eServer components\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#server-components\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eServer Components represent a new type of React component specifically designed to operate exclusively on the server\u003c/li\u003e\n\u003cli\u003eAnd unlike client components, their code stays on the server and is never downloaded to the client \u003c/li\u003e\n\u003cli\u003eThis design choice offers multiple benefits to React applications\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eBenefits\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eSmaller bundle sizes\u003c/strong\u003e: Since Server Components stay on the server, all their dependencies stay there too. This is fantastic for users with slower connections or less powerful devices since they don't need to download, parse, and execute that JavaScript.\nPlus, there's no hydration step, making your app load and become interactive faster\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eDirect access to server-side resources\u003c/strong\u003e: Server Components \u003cstrong\u003ecan talk directly to databases and file systems\u003c/strong\u003e, making data fetching super efficient without any client-side processing.\nThey use the server's power and proximity to data sources to manage compute-intensive rendering tasks.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eEnhanced security\u003c/strong\u003e: Since SC only run on server, sensitive data like API keys never leave the server.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eImproved data fetching\u003c/strong\u003e: since SC are closer to data source, this can improve performance by reducing time it takes to fetch data needed for rendering.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eCaching\u003c/strong\u003e: can cache the results and reuse them for different users and requests\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eFaster initial load \u0026#x26; FCP\u003c/strong\u003e: By generating HTML on the server, users see your content immediately- no waiting for JS to download and execute.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eImproved SEO\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eEfficient Streaming\u003c/strong\u003e: SC can split the rendering process into chunks that stream to client as they're ready. This means users start seeing content faster instead of waiting for entire page to render on the server.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eServer components handle data fetching and static rendering, client components take care of rendering the interactive elements.\u003c/p\u003e\n\u003ch3 id=\"rsc-payload\"\u003ersc payload\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#rsc-payload\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003ethese files have a special JSOn format are generated by react for each route and represent your virtual DOM in a super compavct way using abbreviations and internal references.\u003c/li\u003e\n\u003cli\u003efr server components it also includes the actual rendered result.\u003c/li\u003e\n\u003cli\u003eCC rsc payload is a bit different,it has placeholders showing where the CC should go + refernces to their JS files\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003c/p\u003e\u003cp\u003e\u003c/p\u003e\n\u003chr\u003e\n\u003cstrong\u003eChildren\u003c/strong\u003e\n\u003col\u003e\n\u003cli\u003e\u003ca href=\"/Frontend-JsDev-Handbook/notes/ubgj4b3onoq9pj080dri1nj\"\u003eReact Server Components\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e","noteIndex":{"id":"dlb5bmx7v8f6otsgongz4vx","title":"Hi","desc":"","updated":1663067414354,"created":1648190029829,"custom":{"nav_order":0,"permalink":"/"},"fname":"root","type":"note","vault":{"fsPath":".","selfContained":true,"name":"Harshita-notes","sync":"sync"},"contentHash":"5e58da66991a53ed4cf17d0cade77fe6","links":[{"type":"wiki","from":{"fname":"root","id":"dlb5bmx7v8f6otsgongz4vx","vaultName":"Harshita-notes"},"value":"user.tharshita13","alias":"@tharshita13","position":{"start":{"line":15,"column":12,"offset":433},"end":{"line":15,"column":24,"offset":445},"indent":[]},"xvault":false,"to":{"fname":"user.tharshita13"}}],"anchors":{"contacts":{"type":"header","text":"Contacts","value":"contacts","line":13,"column":0,"depth":2}},"children":["trkx8xrg7g2fm023ez4ldqj","c8csxid3zoghxorepwcrami","urj8q1uq98o3upmgbt2qxns","ykyv5ng8vb44dx8wlchugby","qfxhhwhykm8ml24xxlu67v3","fmv0zz06pgij3bozzx9zes9"],"parent":null,"data":{},"body":"\nHi,\nWelcome to Harshita's Digital Garden 🌱\nI'm Harshita Joshi. I'm a software engineer.\nWhen not at the computer, I play ukulele, do yoga, study [German](https://harshita-mindfire.github.io/german-for-beginners/) and wonder about having numerous pets.\n\n## Contacts\n\nYou can find and contact me in the following places\n\n- Email: tharshita13@gmail.com\n\n- Github: [Harshita-mindfire](https://github.com/Harshita-mindfire)\n\n- Medium: [@tharshita13](https://medium.com/@tharshita13)\n\n- LinkedIn: [Harshita Joshi](https://www.linkedin.com/in/harshita-joshi-030b29118/)\n\n- Instagram: [imharshita07](https://www.instagram.com/imharshita07/)\n"},"collectionChildren":null,"customHeadContent":null,"config":{"version":5,"dev":{"enablePreviewV2":true,"enableSelfContainedVaults":true,"enableEngineV3":true},"commands":{"lookup":{"note":{"selectionMode":"extract","confirmVaultOnCreate":true,"vaultSelectionModeOnCreate":"smart","leaveTrace":false,"bubbleUpCreateNew":true,"fuzzThreshold":0.2}},"randomNote":{},"insertNoteLink":{"aliasMode":"none","enableMultiSelect":false},"insertNoteIndex":{"enableMarker":false},"copyNoteLink":{"aliasMode":"title"},"templateHierarchy":"template"},"workspace":{"vaults":[{"fsPath":".","selfContained":true,"name":"Harshita-notes","sync":"sync"}],"journal":{"dailyDomain":"daily","name":"journal","dateFormat":"y.MM.dd","addBehavior":"childOfDomain"},"scratch":{"name":"scratch","dateFormat":"y.MM.dd.HHmmss","addBehavior":"asOwnDomain"},"task":{"name":"task","dateFormat":"y.MM.dd","addBehavior":"asOwnDomain","statusSymbols":{"":" ","wip":"w","done":"x","assigned":"a","moved":"m","blocked":"b","delegated":"l","dropped":"d","pending":"y"},"taskCompleteStatus":["done","x"],"prioritySymbols":{"H":"high","M":"medium","L":"low"},"todoIntegration":false,"createTaskSelectionType":"selection2link"},"graph":{"zoomSpeed":1,"createStub":false},"enableAutoCreateOnDefinition":false,"enableXVaultWikiLink":false,"enableRemoteVaultInit":true,"enableUserTags":true,"enableHashTags":true,"workspaceVaultSyncMode":"noCommit","enableAutoFoldFrontmatter":false,"enableEditorDecorations":true,"maxPreviewsCached":10,"maxNoteLength":204800,"enableFullHierarchyNoteTitle":false},"preview":{"enableFMTitle":true,"enableNoteTitleForLink":true,"enableFrontmatterTags":true,"enableHashesForFMTags":false,"enablePrettyRefs":true,"enableKatex":true,"automaticallyShowPreview":false},"publishing":{"enableFMTitle":true,"enableNoteTitleForLink":true,"enablePrettyRefs":true,"enableKatex":true,"copyAssets":true,"siteHierarchies":["root"],"writeStubs":false,"siteRootDir":"docs","seo":{"title":"Digital Garden","description":"Personal Knowledge Space"},"github":{"enableEditLink":true,"editLinkText":"Edit this page on GitHub","editBranch":"main","editViewMode":"tree"},"enableSiteLastModified":true,"enableFrontmatterTags":true,"enableHashesForFMTags":false,"enableRandomlyColoredTags":true,"enableTaskNotes":true,"enablePrettyLinks":true,"searchMode":"search","siteUrl":"https://Harshita-mindfire.github.io","assetsPrefix":"/Frontend-JsDev-Handbook","siteFaviconPath":"favicon.ico","siteIndex":"root"}}},"__N_SSG":true},"page":"/notes/[id]","query":{"id":"kgx3khbrerpazr8go9comf8"},"buildId":"xOzf4DPnOhx7yXDruly4o","assetPrefix":"/Frontend-JsDev-Handbook","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>