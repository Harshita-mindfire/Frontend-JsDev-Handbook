{"pageProps":{"note":{"id":"kgx3khbrerpazr8go9comf8","title":"Rendering","desc":"","updated":1753789040778,"created":1753789040778,"custom":{},"fname":"learning.nextjs.rendering","type":"note","vault":{"fsPath":".","selfContained":true,"name":"Harshita-notes","sync":"sync"},"contentHash":"101d9f16b2af2016cbe0d64934454f3d","links":[{"type":"ref","from":{"fname":"learning.nextjs.rendering","id":"kgx3khbrerpazr8go9comf8","vaultName":"Harshita-notes"},"value":"learning.nextjs.rendering.react-server-components","position":{"start":{"line":94,"column":1,"offset":4125},"end":{"line":94,"column":55,"offset":4179},"indent":[]},"xvault":false,"to":{"fname":"learning.nextjs.rendering.react-server-components"}}],"anchors":{"client-side-rendering":{"type":"header","text":"Client side rendering","value":"client-side-rendering","line":14,"column":0,"depth":2},"drawbacks-of-csr":{"type":"header","text":"Drawbacks of CSR","value":"drawbacks-of-csr","line":19,"column":0,"depth":3},"server-side-solutions":{"type":"header","text":"Server side solutions","value":"server-side-solutions","line":28,"column":0,"depth":2},"hydration":{"type":"header","text":"Hydration","value":"hydration","line":40,"column":0,"depth":3},"drawbacks-of-ssr":{"type":"header","text":"Drawbacks of SSR","value":"drawbacks-of-ssr","line":49,"column":0,"depth":3},"suspense-ssr":{"type":"header","text":"Suspense SSR","value":"suspense-ssr","line":72,"column":0,"depth":3},"drawbacks-of-suspense-ssr":{"type":"header","text":"Drawbacks of suspense ssr","value":"drawbacks-of-suspense-ssr","line":92,"column":0,"depth":3},"react-server-components":{"type":"header","text":"React Server components","value":"react-server-components","line":99,"column":0,"depth":3}},"children":["ubgj4b3onoq9pj080dri1nj"],"parent":"w1drku1nbeoq0yf2h0ii7lx","data":{}},"body":"<h1 id=\"rendering\">Rendering<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#rendering\"></a></h1>\n<ul>\n<li>CSR</li>\n<li>SSR</li>\n<li>SSG</li>\n<li>suspense SSR</li>\n<li>React server components</li>\n</ul>\n<h2 id=\"client-side-rendering\">Client side rendering<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#client-side-rendering\"></a></h2>\n<ul>\n<li>The approach where browser(client) transforms react components into what you see on screen.</li>\n</ul>\n<p><img src=\"/Frontend-JsDev-Handbook/assets/images/CSR.png\" alt=\"alt text\"></p>\n<h3 id=\"drawbacks-of-csr\">Drawbacks of CSR<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#drawbacks-of-csr\"></a></h3>\n<ul>\n<li>\n<p><strong>SEO</strong>: When SEs crawl your site, they are looking for HTMl content to understand what the page is about. But with CSR, the page source is basically an empty div. Since content relies on JS to render on Client site, SE struggles to index it properly.</p>\n</li>\n<li>\n<p><strong>Performance and UX</strong>: users can suffer from slow load times, as their browser download, parse and execute JS before seeing any meaningful content.</p>\n</li>\n</ul>\n<h2 id=\"server-side-solutions\">Server side solutions<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#server-side-solutions\"></a></h2>\n<p><img src=\"/Frontend-JsDev-Handbook/assets/images/SSR.png\" alt=\"alt text\"></p>\n<ol>\n<li>Static Site Generation (SSG)</li>\n<li>Server-Side Rendering (SSR)</li>\n</ol>\n<p>SSG happens during build time when you deploy your application to the server. This results in pages that are already rendered and ready to serve. It's perfect for content that stays relatively stable, like blog posts</p>\n<p>SSR, on the other hand, renders pages on-demand when users request them. It's ideal for personalized content like social media feeds where the HTML changes based on who's logged in.</p>\n<h3 id=\"hydration\">Hydration<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#hydration\"></a></h3>\n<p>(react adding interactivity to the server rendered HTML)</p>\n<p>During hydration, React takes control in the browser and reconstructs the component tree in memory, using the server-rendered HTML as a blueprint</p>\n<p>It carefully maps out where all the interactive elements should go, then hooks up the JavaScript logic</p>\n<p>This involves initializing application state, adding click and mouseover handlers, and setting up all the dynamic features needed for a full interactive user experience.</p>\n<h3 id=\"drawbacks-of-ssr\">Drawbacks of SSR<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#drawbacks-of-ssr\"></a></h3>\n<ul>\n<li><strong>You have to fetch everything before you can show anything</strong></li>\n</ul>\n<p>Components cannot start rendering and then pause or \"wait\" while data is still being loaded</p>\n<p>If a component needs to fetch data from a database or another source (like an API), this fetching must be completed before the server can begin rendering the page</p>\n<p>This can delay the server's response time to the browser, as the server must finish collecting all necessary data before any part of the page can be sent to the client</p>\n<ul>\n<li><strong>You have to load everything before you can hydrate anything</strong></li>\n</ul>\n<p>For successful hydration, where React adds interactivity to the server-rendered HTML, the component tree in the browser must exactly match the server-generated component tree</p>\n<p>This means that all the JavaScript for the components must be loaded on the client before you can start hydrating any of them.</p>\n<ul>\n<li><strong>You have to hydrate everything before you can interact with anything</strong></li>\n</ul>\n<p>React hydrates the component tree in a single pass, meaning once it starts hydrating, it won't stop until it's finished with the entire tree</p>\n<p>As a consequence, all components must be hydrated before you can interact with any of them.</p>\n<h3 id=\"suspense-ssr\">Suspense SSR<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#suspense-ssr\"></a></h3>\n<p>Use the <code>&#x3C;Suspense></code> componenet to unlock 2 major SSR features:</p>\n<ul>\n<li>HTML streaming on server</li>\n<li>Selective hydration on the client.</li>\n</ul>\n<p>This solves the 3 all or nothing concerns of SSR: </p>\n<ol>\n<li>having to load the data for the entire page. \n<blockquote>\n<p>React 18+ can fix this via <code>&#x3C;Suspense></code></p>\n</blockquote>\n</li>\n<li>loading the JavaScript for the entire page\n<blockquote>\n<p>can be fixed with code splitting.</p>\n</blockquote>\n</li>\n<li>hydrating the entire page.\n<blockquote>\n<p>Suspense also allows React to let hydrate other parts of the page before the section wrapped within it is ready. This is what we call: <strong>selective hydration</strong>. In scenarios where multiple components are awaiting hydration, React prioritizes hydration based on user interactions</p>\n</blockquote>\n</li>\n</ol>\n<p>at once, create an \"all or nothing\" waterfall problem that spans from the server to the client, where each issue must be resolved before moving to the next one</p>\n<h3 id=\"drawbacks-of-suspense-ssr\">Drawbacks of suspense ssr<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#drawbacks-of-suspense-ssr\"></a></h3>\n<p>raises 3 question:</p>\n<ol>\n<li>do user still need to download so much data(loading entire webpage bit by bit)</li>\n<li>should all components be hydrated, even those that don't need interactivity(static content components)</li>\n<li>Shouldn't we be leverging our servers more(user's device do bulk of the JS work which can slow things down)</li>\n</ol>\n<h3 id=\"react-server-components\">React Server components<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#react-server-components\"></a></h3>\n<p></p><p></p><div class=\"portal-container\">\n<div class=\"portal-head\">\n<div class=\"portal-backlink\">\n<div class=\"portal-title\">From <span class=\"portal-text-title\">React Server Components</span></div>\n<a href=\"/Frontend-JsDev-Handbook/notes/ubgj4b3onoq9pj080dri1nj\" class=\"portal-arrow\">Go to text <span class=\"right-arrow\">â†’</span></a>\n</div>\n</div>\n<div id=\"portal-parent-anchor\" class=\"portal-parent\" markdown=\"1\">\n<div class=\"portal-parent-fader-top\"></div>\n<div class=\"portal-parent-fader-bottom\"></div><p><strong>The app router in Nextjs is built entirely on RSC architecture. All these features are built into the latest version of Nextjs</strong></p>\n<h2 id=\"takeaways\">Takeaways<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#takeaways\"></a></h2>\n<ul>\n<li>React Server Components offer a new approach to building React apps by separating components into two: Server Components and Client Components</li>\n<li>Server Components run exclusively on the server - they fetch data and prepare content without sending code to the browser</li>\n<li>This makes your app faster because users download less code</li>\n</ul>\n<p>However, they can't handle any interactions</p>\n<ul>\n<li>Client Components, on the other hand, run in the browser and manage all the interactive parts like clicks and typing</li>\n<li>They can also get an initial server render for faster page loads</li>\n</ul>\n<h2 id=\"react-server-components-1\">React Server components<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#react-server-components-1\"></a></h2>\n<p>evolution of react CSR--> SSR ---> Suspense SSR---> RSC</p>\n<ul>\n<li>\n<p>represents a new architechture, which leverages the strengths of both server and client environments to optimize efficiency, load times and interactivity..</p>\n</li>\n<li>\n<p>Introduces dual models:</p>\n<ul>\n<li>client components</li>\n<li>server components</li>\n</ul>\n</li>\n</ul>\n<p>This distiction is based on the environment they would execute and the specific systems they are designed to interact with, for eg: browser apis, hooks, goes in client components.</p>\n<h3 id=\"client-components\">Client components<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#client-components\"></a></h3>\n<ul>\n<li>first rendered on the server then on the client.</li>\n<li>in nextjs, use \"use client\" to differentiate the components as a CC.</li>\n</ul>\n<h3 id=\"server-components\">Server components<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#server-components\"></a></h3>\n<ul>\n<li>Server Components represent a new type of React component specifically designed to operate exclusively on the server</li>\n<li>And unlike client components, their code stays on the server and is never downloaded to the client </li>\n<li>This design choice offers multiple benefits to React applications</li>\n</ul>\n<p><strong>Benefits</strong></p>\n<ul>\n<li><strong>Smaller bundle sizes</strong>: Since Server Components stay on the server, all their dependencies stay there too. This is fantastic for users with slower connections or less powerful devices since they don't need to download, parse, and execute that JavaScript.\nPlus, there's no hydration step, making your app load and become interactive faster</li>\n<li><strong>Direct access to server-side resources</strong>: Server Components <strong>can talk directly to databases and file systems</strong>, making data fetching super efficient without any client-side processing.\nThey use the server's power and proximity to data sources to manage compute-intensive rendering tasks.</li>\n<li><strong>Enhanced security</strong>: Since SC only run on server, sensitive data like API keys never leave the server.</li>\n<li><strong>Improved data fetching</strong>: since SC are closer to data source, this can improve performance by reducing time it takes to fetch data needed for rendering.</li>\n<li><strong>Caching</strong>: can cache the results and reuse them for different users and requests</li>\n<li><strong>Faster initial load &#x26; FCP</strong>: By generating HTML on the server, users see your content immediately- no waiting for JS to download and execute.</li>\n<li><strong>Improved SEO</strong></li>\n<li><strong>Efficient Streaming</strong>: SC can split the rendering process into chunks that stream to client as they're ready. This means users start seeing content faster instead of waiting for entire page to render on the server.</li>\n</ul>\n<p>Server components handle data fetching and static rendering, client components take care of rendering the interactive elements.</p>\n<h3 id=\"rsc-payload\">rsc payload<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#rsc-payload\"></a></h3>\n<ul>\n<li>these files have a special JSOn format are generated by react for each route and represent your virtual DOM in a super compavct way using abbreviations and internal references.</li>\n<li>fr server components it also includes the actual rendered result.</li>\n<li>CC rsc payload is a bit different,it has placeholders showing where the CC should go + refernces to their JS files</li>\n</ul>\n</div></div><p></p><p></p>\n<hr>\n<strong>Children</strong>\n<ol>\n<li><a href=\"/Frontend-JsDev-Handbook/notes/ubgj4b3onoq9pj080dri1nj\">React Server Components</a></li>\n</ol>","noteIndex":{"id":"dlb5bmx7v8f6otsgongz4vx","title":"Hi","desc":"","updated":1663067414354,"created":1648190029829,"custom":{"nav_order":0,"permalink":"/"},"fname":"root","type":"note","vault":{"fsPath":".","selfContained":true,"name":"Harshita-notes","sync":"sync"},"contentHash":"5e58da66991a53ed4cf17d0cade77fe6","links":[{"type":"wiki","from":{"fname":"root","id":"dlb5bmx7v8f6otsgongz4vx","vaultName":"Harshita-notes"},"value":"user.tharshita13","alias":"@tharshita13","position":{"start":{"line":15,"column":12,"offset":433},"end":{"line":15,"column":24,"offset":445},"indent":[]},"xvault":false,"to":{"fname":"user.tharshita13"}}],"anchors":{"contacts":{"type":"header","text":"Contacts","value":"contacts","line":13,"column":0,"depth":2}},"children":["trkx8xrg7g2fm023ez4ldqj","c8csxid3zoghxorepwcrami","urj8q1uq98o3upmgbt2qxns","ykyv5ng8vb44dx8wlchugby","qfxhhwhykm8ml24xxlu67v3","fmv0zz06pgij3bozzx9zes9"],"parent":null,"data":{},"body":"\nHi,\nWelcome to Harshita's Digital Garden ðŸŒ±\nI'm Harshita Joshi. I'm a software engineer.\nWhen not at the computer, I play ukulele, do yoga, study [German](https://harshita-mindfire.github.io/german-for-beginners/) and wonder about having numerous pets.\n\n## Contacts\n\nYou can find and contact me in the following places\n\n- Email: tharshita13@gmail.com\n\n- Github: [Harshita-mindfire](https://github.com/Harshita-mindfire)\n\n- Medium: [@tharshita13](https://medium.com/@tharshita13)\n\n- LinkedIn: [Harshita Joshi](https://www.linkedin.com/in/harshita-joshi-030b29118/)\n\n- Instagram: [imharshita07](https://www.instagram.com/imharshita07/)\n"},"collectionChildren":null,"customHeadContent":null,"config":{"version":5,"dev":{"enablePreviewV2":true,"enableSelfContainedVaults":true,"enableEngineV3":true},"commands":{"lookup":{"note":{"selectionMode":"extract","confirmVaultOnCreate":true,"vaultSelectionModeOnCreate":"smart","leaveTrace":false,"bubbleUpCreateNew":true,"fuzzThreshold":0.2}},"randomNote":{},"insertNoteLink":{"aliasMode":"none","enableMultiSelect":false},"insertNoteIndex":{"enableMarker":false},"copyNoteLink":{"aliasMode":"title"},"templateHierarchy":"template"},"workspace":{"vaults":[{"fsPath":".","selfContained":true,"name":"Harshita-notes","sync":"sync"}],"journal":{"dailyDomain":"daily","name":"journal","dateFormat":"y.MM.dd","addBehavior":"childOfDomain"},"scratch":{"name":"scratch","dateFormat":"y.MM.dd.HHmmss","addBehavior":"asOwnDomain"},"task":{"name":"task","dateFormat":"y.MM.dd","addBehavior":"asOwnDomain","statusSymbols":{"":" ","wip":"w","done":"x","assigned":"a","moved":"m","blocked":"b","delegated":"l","dropped":"d","pending":"y"},"taskCompleteStatus":["done","x"],"prioritySymbols":{"H":"high","M":"medium","L":"low"},"todoIntegration":false,"createTaskSelectionType":"selection2link"},"graph":{"zoomSpeed":1,"createStub":false},"enableAutoCreateOnDefinition":false,"enableXVaultWikiLink":false,"enableRemoteVaultInit":true,"enableUserTags":true,"enableHashTags":true,"workspaceVaultSyncMode":"noCommit","enableAutoFoldFrontmatter":false,"enableEditorDecorations":true,"maxPreviewsCached":10,"maxNoteLength":204800,"enableFullHierarchyNoteTitle":false},"preview":{"enableFMTitle":true,"enableNoteTitleForLink":true,"enableFrontmatterTags":true,"enableHashesForFMTags":false,"enablePrettyRefs":true,"enableKatex":true,"automaticallyShowPreview":false},"publishing":{"enableFMTitle":true,"enableNoteTitleForLink":true,"enablePrettyRefs":true,"enableKatex":true,"copyAssets":true,"siteHierarchies":["root"],"writeStubs":false,"siteRootDir":"docs","seo":{"title":"Digital Garden","description":"Personal Knowledge Space"},"github":{"enableEditLink":true,"editLinkText":"Edit this page on GitHub","editBranch":"main","editViewMode":"tree"},"enableSiteLastModified":true,"enableFrontmatterTags":true,"enableHashesForFMTags":false,"enableRandomlyColoredTags":true,"enableTaskNotes":true,"enablePrettyLinks":true,"searchMode":"search","siteUrl":"https://Harshita-mindfire.github.io","assetsPrefix":"/Frontend-JsDev-Handbook","siteFaviconPath":"favicon.ico","siteIndex":"root"}}},"__N_SSG":true}